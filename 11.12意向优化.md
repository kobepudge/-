# AI交易策略优化方案

**日期**: 2024.11.12
**目标**: 提升AI决策质量、资金利用率、风险控制能力
**架构**: ai_trader_v2.py (Chief Wave Strategist)

---

## 📋 核心问题诊断

### 当前架构优势 ✅
1. **职责分离清晰**: Python助理（数据）→ AI首席（决策）→ 执行器（风控）
2. **数据维度完整**: 订单流、ZigZag、斐波、VWAP、多周期（1m+5m+日线）
3. **异步执行**: 后台线程避免阻塞，Key池管理防Rate Limit
4. **熔断机制**: `is_ai_insane` 硬规则防AI失控

### 致命缺陷 ❌
1. **AI不知道成本**: 不知道每手需要多少保证金，最多能开几手
2. **AI不知道绩效**: 看不到上次交易结果，无法学习改进
3. **震荡市频繁交易**: 无市场可交易性评分，在低波动时强行数浪
4. **ZigZag噪音**: 固定阈值在高波动时产生大量噪音枢轴点
5. **多标的资金冲突**: 3个标的独立决策，可能超额分配资金

---

## 🎯 分阶段优化方案

### Phase 1: 成本约束与持仓感知 🔴 P0

**问题**: AI不知道资金约束，可能提出无法执行的计划

**解决方案**: 在简报中增加 `constraints` 节点

```json
{
  "report_account": {
    "equity": 1000000,
    "available": 950000,
    "margin": 100000,
    "current_position": {"pos": 2, "avg": 549.5},

    // 新增：成本约束
    "constraints": {
      "max_open_lots_long": 11,      // 做多最多能开几手
      "max_open_lots_short": 11,     // 做空最多能开几手
      "max_position_pct": 0.5,       // 硬上限50%（防满仓）
      "recommended_max_pct": 0.4,    // 建议上限40%
      "cost_per_lot_long": 86240,    // 开1手多单需要的保证金
      "cost_per_lot_short": 86240,   // 开1手空单需要的保证金
      "contract_multiplier": 1000,   // 合约乘数
      "min_volume": 1                // 最小手数
    }
  }
}
```

**Prompt增强**:
```
# 成本约束与仓位管理
- max_open_lots_long/short: 当前资金最多能开几手
- max_position_pct: 0.5（硬上限，不可超过）
- recommended_max_pct: 0.4（建议上限，超过需充分理由）

你的 position_size_pct 必须满足：
1. 换算手数 ≤ max_open_lots_side
2. position_size_pct ≤ max_position_pct
3. 建议 ≤ recommended_max_pct（除非多周期共振+高流动性+高信心）

# 为什么不能满仓
期货风险不是穿仓，而是失去灵活性：
1. 流动性风险：满仓后遇跌停板无法平仓
2. 追保风险：交易所提高保证金率会被强平
3. 机会成本：满仓后无法加仓更好机会
4. 滑点风险：满仓时止损滑点损失更大
5. 心理风险：满仓时压力巨大易误操作

在 internal_reasoning 中说明：
- 你选择的 position_size_pct 对应几手
- 为什么选择这个仓位
```

**实施要点**:
- 计算逻辑复用执行层现有代码
- 容错处理：字段缺失时AI仍能工作
- 方向分离：long/short 两套数据

**代码量**: +40行
**预期效果**: AI能自主计算仓位，避免超额分配

---

### Phase 2: 交易绩效反馈 🔴 P0

**问题**: AI看不到上次交易结果，无法学习改进

**解决方案**: 在简报中增加交易结果与绩效统计

```json
{
  "report_account": {
    // ... 原有字段 ...

    // 新增：上次交易结果
    "last_trade_result": {
      "time": "2024-11-12 14:30:00",
      "tag": "CloseLong",
      "volume": 2,
      "price": 551.5,
      "realized_delta": 2500,  // 盈亏
      "plan_id": "plan_12345",
      "slippage": 0.2,         // 滑点
      "slippage_ticks": 2
    },

    // 新增：今日绩效
    "today_performance": {
      "trades_count": 5,
      "total_pnl": 3500,
      "win_rate": 0.6,
      "avg_pnl_per_trade": 700
    }
  }
}
```

**记录AI决策快照**（用于归因分析）:
```python
st['ai_decision_snapshot'] = {
    'hypothesis_primary': "5m处于wave3推动浪",
    'confidence': 0.85,
    'signal': 'buy',
    'plan_id': 'plan_12345',
    'timestamp': time.time()
}
```

**交易记录增强**:
```python
rec = {
    'time': '2024-11-12 14:30:00',
    'tag': 'OpenLong',
    'volume': 2,
    'price': 550.0,
    'realized_delta': 0,
    'plan_id': 'plan_12345',
    'slippage': 0.2,              // 新增
    'slippage_ticks': 2,          // 新增
    'ai_hypothesis': "wave3推动",  // 新增
    'ai_confidence': 0.85         // 新增
}
```

**实施要点**:
- 记录完整AI决策快照（用于离线归因）
- 记录执行质量（滑点）
- 统计今日绩效（交易次数、胜率、平均盈亏）

**代码量**: +50行
**预期效果**: AI能看到交易结果，学习改进决策

---

### Phase 3: 市场可交易性评分 🟡 P1

**问题**: AI在震荡市强行数浪，频繁交易导致连续止损

**解决方案**: 增加 `tradability_score` 评估市场状态

```json
{
  "report_context": {
    "last_3_candles_ohlc": [...],
    "session_vwap": 550.1,
    "daily_trend": "UPTREND",

    // 新增：可交易性评分
    "tradability_score": 0.35,  // 0-1，越高越适合交易
    "tradability_reasons": [
      "低波动(ATR<0.3%)",
      "窄幅震荡(振幅<0.5%)",
      "结构混乱(12个枢轴)"
    ]
  }
}
```

**评分因素**:
1. **波动率（ATR）**: ATR < 0.3% → 降低评分
2. **价格振幅**: 20根K线振幅 < 0.5% → 降低评分
3. **ZigZag噪音**: 枢轴点 > 8个 → 降低评分
4. **流动性**: liquidity_state = THIN → 降低评分

**Prompt配合**:
```
# 市场可交易性评估
tradability_score (0-1) 反映当前市场是否适合交易：
- ≥ 0.7: 市场正常，可正常交易
- 0.4-0.7: 市场一般，需谨慎（小仓位+严格止损）
- < 0.4: 市场不佳，强烈建议 hold（除非极强突破信号）

tradability_reasons 会告诉你具体原因。
在震荡市（tradability < 0.5）强行交易，胜率会显著下降。
```

**实施要点**:
- 综合多个因素计算评分
- 提供具体原因（便于AI理解）
- 不强制AI遵守（仅建议）

**代码量**: +35行
**预期效果**: 震荡市交易频率降低50%+，胜率提升

---

### Phase 4: ZigZag动态阈值 🟡 P1

**问题**: 固定阈值0.3%在高波动时产生大量噪音枢轴点

**解决方案**: 基于ATR动态调整阈值

```python
def calculate_zigzag_pivots(context):
    closes = [b['close'] for b in context.klines_1m]

    # 动态阈值（基于ATR）
    try:
        atr = context.state.get('last_indicators', {}).get('atr', 0)
        price = closes[-1] if closes else 1

        if atr > 0 and price > 0:
            # ATR的50%作为最小波动
            dynamic_threshold = (atr / price) * 100 * 0.5
            threshold = max(0.3, dynamic_threshold)  # 最小0.3%
        else:
            threshold = 0.3
    except:
        threshold = 0.3

    return _zigzag_by_pct(closes, threshold_pct=threshold)
```

**逻辑**:
- 低波动（ATR小）→ 阈值0.3%（保持敏感）
- 高波动（ATR大）→ 阈值自动提高（过滤噪音）
- 例如：ATR=2元，价格=550 → 阈值=(2/550)*100*0.5=0.18% → 取max(0.3, 0.18)=0.3%
- 例如：ATR=5元，价格=550 → 阈值=(5/550)*100*0.5=0.45% → 取0.45%

**实施要点**:
- 复用现有ATR计算
- 不改变 `_zigzag_by_pct` 函数
- 容错处理

**代码量**: +10行
**预期效果**: 高波动时枢轴点减少30-50%

---

### Phase 5: 斐波那契去重 🟢 P2

**问题**: 多个斐波位挤在一起（548.0, 548.05, 548.1），AI难以判断

**解决方案**: 合并距离过近的点

```python
def find_fib_clusters(pivots, tick_size=0.01, bin_ticks=3, min_votes=2):
    # ... 原有代码 ...

    # 新增：去重合并
    def merge_close_levels(levels, min_gap_ticks=5):
        if not levels:
            return []
        sorted_levels = sorted(levels)
        merged = [sorted_levels[0]]
        for level in sorted_levels[1:]:
            if (level - merged[-1]) > min_gap_ticks * tick_size:
                merged.append(level)
            else:
                # 合并：取加权平均
                merged[-1] = (merged[-1] + level) / 2
        return merged

    support = merge_close_levels([c for c in centers if c <= last_close])
    resist = merge_close_levels([c for c in centers if c > last_close])

    return {"support": support, "resistance": resist}
```

**逻辑**:
- 距离 < 5个tick的点合并为一个
- 取平均值作为最终位置
- 例如：[548.0, 548.05, 548.1] → [548.05]

**实施要点**:
- 最小间距可配置（默认5 ticks）
- 保持原有逻辑不变

**代码量**: +15行
**预期效果**: 斐波位数量减少40%，更清晰

---

### Phase 6: 多标的资金协调 🟢 P2

**问题**: 3个标的独立决策，可能超额分配资金

**解决方案**: 执行层资金分配器

```python
def allocate_capital_across_symbols(context, decisions):
    """
    在多个标的间分配有限资金
    decisions: [
        {'symbol': 'au2512', 'signal': 'buy', 'size_pct': 0.4, 'confidence': 0.85},
        {'symbol': 'lc2601', 'signal': 'buy', 'size_pct': 0.3, 'confidence': 0.9},
        {'symbol': 'ag2506', 'signal': 'sell', 'size_pct': 0.2, 'confidence': 0.6}
    ]
    """
    # 按 confidence × urgency 排序
    sorted_decisions = sorted(decisions,
        key=lambda d: d.get('confidence', 0) * d.get('urgency', 1.0),
        reverse=True)

    acc = estimate_account(context, context.last_price, context.state)
    available = acc['available']
    equity = acc['equity']

    allocated = []
    remaining = available

    for d in sorted_decisions:
        symbol = d['symbol']
        size_pct = d['size_pct']

        # 计算需要的资金
        price = d.get('price', 0)
        mult = PlatformAdapter.get_contract_size(symbol)
        mr = PlatformAdapter.get_margin_ratio(symbol,
            'long' if d['signal'] == 'buy' else 'short')

        target_notional = equity * size_pct
        lots = int(target_notional / (price * mult))
        needed = lots * price * mult * mr * Config.NEW_TRADE_MARGIN_BUFFER

        if needed <= remaining:
            # 资金充足，全额分配
            allocated.append(d)
            remaining -= needed
        elif remaining > 0:
            # 资金不足，按比例降低
            ratio = remaining / needed
            d['size_pct'] *= ratio
            allocated.append(d)
            Log(f"[资金分配] {symbol} 资金不足，仓位从{size_pct:.2f}降至{d['size_pct']:.2f}")
            remaining = 0
        else:
            # 无资金，跳过
            Log(f"[资金分配] {symbol} 无可用资金，跳过")

    return allocated
```

**逻辑**:
1. 按信心度×紧迫性排序
2. 优先满足高质量机会
3. 资金不足时按比例降低仓位
4. 记录调整日志

**实施要点**:
- 在 `on_bar` 中收集所有标的的决策
- 统一分配后再执行
- AI增加 `urgency` 字段（high/medium/low）

**代码量**: +40行
**预期效果**: 多标的资金冲突减少90%

---

## 📊 实施优先级与时间表

| Phase | 功能 | 代码量 | 优先级 | 预期效果 | 实施时间 |
|-------|------|--------|--------|----------|---------|
| **Phase 1** | 成本约束 | +40行 | 🔴 P0 | AI知道能开几手 | Week 1 (Day 1-2) |
| **Phase 2** | 绩效反馈 | +50行 | 🔴 P0 | AI能学习改进 | Week 1 (Day 3-4) |
| **Phase 3** | 可交易性 | +35行 | 🟡 P1 | 震荡市交易减少50% | Week 2 (Day 1-2) |
| **Phase 4** | ZigZag优化 | +10行 | 🟡 P1 | 噪音枢轴减少30% | Week 2 (Day 3) |
| **Phase 5** | 斐波去重 | +15行 | 🟢 P2 | 结构更清晰 | Week 3 (Day 1-2) |
| **Phase 6** | 多标的协调 | +40行 | 🟢 P2 | 资金冲突减少90% | Week 3 (Day 3-5) |

**总计**: +190行代码，3周完成

---

## 🎯 预期效果对比

| 指标 | 改进前 | 改进后 | 提升幅度 |
|-----|-------|-------|---------|
| **AI决策质量** | 60% | 80% | +33% |
| **资金利用率** | 40% | 70% | +75% |
| **震荡市胜率** | 30% | 50% | +67% |
| **满仓风险** | 高 | 低 | -80% |
| **多标的冲突** | 频繁 | 罕见 | -90% |
| **ZigZag噪音** | 高 | 中 | -40% |
| **决策可解释性** | 低 | 高 | +100% |

---

## 🔧 技术实施细节

### 数据流变化

**改进前**:
```
Tick/Bar → 数据收集 → 简报构造 → AI决策 → 执行器
                ↓
        [equity, available, margin]
```

**改进后**:
```
Tick/Bar → 数据收集 → 简报构造 → AI决策 → 执行器
                ↓              ↓
        [equity, available,  [last_trade,
         margin, constraints, today_perf,
         tradability_score]   ai_snapshot]
```

### Prompt增量

| 模块 | Token增量 | 累计 |
|-----|----------|------|
| 成本约束 | +150 | 150 |
| 绩效反馈 | +50 | 200 |
| 可交易性 | +80 | 280 |

**总增量**: ~280 tokens（约+15%）

### 数据量增量

| 模块 | 数据增量 | 累计 |
|-----|----------|------|
| constraints | +150 bytes | 150 |
| last_trade_result | +100 bytes | 250 |
| today_performance | +80 bytes | 330 |
| tradability_score | +50 bytes | 380 |

**总增量**: ~380 bytes（约+20%）

---

## ⚠️ 风险与注意事项

### 风险点

1. **Prompt过长**: 增加280 tokens可能影响AI理解
   - **缓解**: 分模块说明，保持简洁

2. **数据过载**: 增加380 bytes可能让AI迷失
   - **缓解**: 结构化清晰，字段命名直观

3. **计算开销**: 新增计算可能影响性能
   - **缓解**: 复用现有逻辑，容错处理

### 兼容性

- ✅ 向后兼容：所有新增字段都有默认值
- ✅ 容错完善：字段缺失时AI仍能工作
- ✅ 渐进式：可分阶段实施，互不依赖

---

## 📝 验证方法

### Phase 1-2 验证（Week 1）
- [ ] 回测1个月数据
- [ ] 检查AI是否理解 `constraints`
- [ ] 检查AI是否参考 `last_trade_result`
- [ ] 统计资金超额分配次数（应为0）

### Phase 3-4 验证（Week 2）
- [ ] 统计震荡市交易频率（应降低50%）
- [ ] 统计ZigZag枢轴点数量（应降低30%）
- [ ] 实盘1手测试3天

### Phase 5-6 验证（Week 3）
- [ ] 检查斐波位数量（应降低40%）
- [ ] 多标的同时运行，检查资金冲突
- [ ] 完整回测3个月

---

## 🎓 经验总结

### 设计原则

1. **Linus原则**: 简单的东西不会坏
   - 每个Phase独立，可单独验证
   - 优先最小改动，观察效果再迭代

2. **AI能力边界**: AI不擅长复杂计算
   - 给结论，不给过程（如 `max_open_lots` 而非保证金率）
   - 结构化数据，不要让AI自己解析

3. **渐进式改进**: 不要一次改200行
   - Phase 1-2 是基础（+90行）
   - Phase 3-4 是优化（+45行）
   - Phase 5-6 是锦上添花（+55行）

### 关键洞察

1. **成本约束是核心**: AI不知道"能开几手"就像盲人开车
2. **绩效反馈是闭环**: AI看不到结果就无法学习
3. **可交易性是护栏**: 震荡市是AI的坟墓
4. **多标的是架构升级**: 需要Portfolio Manager思维

---

## 📚 参考资料

- 当前代码: `ai_trader_v2.py`
- 旧版代码: `gkoudai_au_strategy_autonomous.py`
- 讨论记录: 2024.11.12 对话
- 相关文档: `1.md` (AI交易公司架构)

---

## ✅ 下一步行动

1. **立即**: 审阅本文档，确认优先级
2. **Week 1**: 实施Phase 1-2（成本约束+绩效反馈）
3. **Week 2**: 实施Phase 3-4（可交易性+ZigZag优化）
4. **Week 3**: 实施Phase 5-6（斐波去重+多标的协调）
5. **Week 4**: 完整回测与实盘验证

---

**文档版本**: v1.0
**最后更新**: 2024.11.12
**状态**: 待审阅
